## 排序

符号：Θ

- 插入排序
- 选择排序
- 堆排序
- 归并排序
- 冒泡排序
- 快速排序
- 计数排序
- 基数排序
- 桶排序

### 插入排序

**插入排序（Insertion Sort）**是一种简单的插入排序法，其基本思想是：把待排序的元素按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的元素插入完为止，得到一个新的有序序列。

#### 比喻

莫扑克牌，开始时，左手为空并且桌子上的牌面向下，然后每次从牌堆最上面拿走一张牌，插入到左手的正确位置上。

<img src="../images/sort/insert.gif"/>


#### 性质

- 最好时间复杂度 : Θ(n)
- 平均时间复杂度 : Θ(n²)
- 最差时间复杂度 : Θ(n²)
- 空间复杂度 : Θ(1)
- 稳定性 : 稳定

#### 伪代码

```
void insertSort(int array[],int length)
{
    for (int i = 1; i < length; i++) {
        int temp = array[i];
        int j = i;
        for (; j > 0; j--) {
            if (array[j-1] > temp) {
                array[j] = array[j-1];
            }else{
                break;
            }
        }
        array[j] = temp;
    }
}
```

递归式：为了排序A[0..k],我们递归地排序A[0...k-1]，然后把A[k]插入到已排序的数组A[0...k-1]中。

```
void recursiveInsertSort(int array[], int length, int cur)
{
	if (cur < 1)
	{
		return;
	}
	//递归前一个数组
	recursiveInsertSort(array, length, cur-1);

	int value = array[cur];
	int j = cur;
	for (; j > 0; j--)
	{
		if (array[j-1] > value){
			array[j] = array[j-1];
		}else{
			break;
		}
	}
	array[j] = value;
}
```

### 选择排序

**选择排序（Selection Sort）**的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，与待排序序列起始位置的元素交换，直到全部待排序的数据元素排完。

<img src="../images/sort/selection.gif"/>

#### 性质

- 最好时间复杂度 : Θ(n²)
- 平均时间复杂度 : Θ(n²)
- 最差时间复杂度 : Θ(n²)
- 空间复杂度 : Θ(1)
- 稳定性 : 不稳定

#### 伪代码

```
void selectionSort(int array[], int length)
{
	for (int i = 0; i < length-1; ++i)
	{
		int min = i;
		for (int j = i+1; j < length; ++j)
		{
			if (array[min] > array[j]){
				min = j;
			}
		}

		if (min != i){
			int temp = array[i];
			array[i] = array[min];
			array[min] = temp;
		}
	}
}
```

### 堆排序

**堆排序（Heap Sort）**指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。

- 堆分为大根堆（k[i]>=k[2i],k[i]>=k[2i+1]）和小根堆（k[i]<=k[2i],k[i]<=k[2i+1]）。(i=1,2,3...⎣n/2⎦)
- 堆是完全二叉树。

实现堆排序要解决两个问题：

1. 将n个待排序的数建成堆。
2. 输出堆顶元素后，调整剩余元素，成为一个新堆。

<img src="../images/sort/heap.jpg">

解决：

问题一：从最后一个非叶子节点（k[⎣n/2⎦]）开始的子树，使之成为堆，依次向前，直到根节点。

问题二：将堆顶输出，最后一个节点换到堆顶，堆被破坏。从堆顶开始，与左右结点中较小（或较大）的元素交换。继续对不满足堆性质的子树进行交换，直到使之成为堆。

#### 性质

- 最好时间复杂度 : Θ(nlgn)
- 平均时间复杂度 : Θ(nlgn)
- 最差时间复杂度 : Θ(nlgn)
- 空间复杂度 : Θ(1)
- 稳定性 : 不稳定

#### 伪代码

```
//注意：这里的i=（1,2,3...n）
void heapSort(int array[], int length)
{
	buildHeap(array, length);
	for (int i = length; i >= 1; i--)
	{
		//交换第一个元素和最后一个元素，即每次将堆顶元素排到未排好序列的最后
		int temp = array[0];	
		array[0] = array[i-1];
		array[i-1] = temp;
		//重新调整为堆
		heapAdjust(array, i-1, 1); 
	}
}

///调整以i结点为根的树为堆
void heapAdjust(int array[], int length, int i)
{
	int lChild = i*2;
	int rChild = i*2 + 1;
	int maxIndex = i;
	//处理非叶子节点
	if (i <= length/2) 
	{
		if (lChild <= length && array[lChild-1] > array[maxIndex-1])
		{
			maxIndex = lChild;
		}
		if (rChild <= length && array[rChild-1] > array[maxIndex-1])
		{
			maxIndex = rChild;
		}
		if (maxIndex != i)
		{
			int temp = array[maxIndex-1];
			array[maxIndex-1] = array[i-1];
			array[i-1] = temp;
			heapAdjust(array, length, maxIndex);
		}
	}
}

///创建堆
void buildHeap(int array[], int length)
{
	//从最后一个非叶子结点开始，调整为堆
	for (int i = length/2; i >= 1; i--)
	{
		heapAdjust(array, length, i);
	}
}
```

### 归并排序

**归并排序（Merge Sort）**是将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。

<div style="width:600px;height:230px;position:relative;overflow:hidden;">
<img src="http://www.th7.cn/d/file/p/2014/12/04/011efc51860c103b29f5a3e652e1ead4.png">
</div>


#### 性质

- 最好时间复杂度 : Θ(nlgn)
- 平均时间复杂度 : Θ(nlgn)
- 最差时间复杂度 : Θ(nlgn)
- 空间复杂度 : Θ(n)
- 稳定性 : 稳定

#### 伪代码

```
void mergeSort(int array[], int tempArray[], int low, int high)
{
	if (low >= high){
		return;
	}

	//递归前半段、后半段
	int mid = (low + high) / 2;
	mergeSort(array, tempArray, low, mid);
	mergeSort(array, tempArray, mid + 1, high);

	int i = low;
	int j = mid + 1;
	int cur = 0;
	while(i <= mid && j <= high)
	{
		if (array[i] < array[j]){
			tempArray[cur] = array[i++];
		}else{
			tempArray[cur] = array[j++];
		}
		cur++;
	}

	while(i <= mid)
	{
		tempArray[cur++] = array[i++];
	}

	while(j <= high)
	{
		tempArray[cur++] = array[j++];
	}

	for (int i = 0; i < cur; ++i)
	{
		array[i+low] = tempArray[i];
	}
}
```

### 冒泡排序

**冒泡排序（Bubble Sort）**在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。

<img src="../images/sort/bubble.gif">

#### 性质

- 最好时间复杂度 : Θ(n)
- 平均时间复杂度 : Θ(n²)
- 最差时间复杂度 : Θ(n²)
- 空间复杂度 : Θ(n)
- 稳定性 : 稳定

#### 伪代码

```
void bubbleSort(int array[], int length)
{
	for (int i = 0; i < length-1; ++i)
	{
		for (int j = 0; j < length-1-i; ++j)
		{
			if (array[j] > array[j+1])
			{
				int temp = array[j];
				array[j] = array[j+1];
				array[j+1] = temp;
			}
		}
	}
}
```

#### 改进

1.设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。

```
void bubbleSort1(int array[], int length)
{
	for (int i = length - 1; i > 0;)
	{
		int pos = 0;
		for (int j = 0; j < i; ++j)
		{
			if (array[j] > array[j+1])
			{
				int temp = array[j];
				array[j] = array[j+1];
				array[j+1] = temp;
				pos = j;
			}
		}
		i = pos;
	}
}
```

2.传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值,我们考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值(最大者和最小者) , 从而使排序趟数几乎减少了一半。

```
void bubbleSort2(int array[], int length)
{
	int low = 0;
	int high = length - 1;
	while(low < high){
		for (int j = low; j < high; j++)
		{
			//正向冒泡
			if (array[j] > array[j+1])
			{
				int temp = array[j];
				array[j] = array[j+1];
				array[j+1] = temp;
			}
		}
		high--;
		for (int j = high; j > low; j--)
		{
			//反向冒泡
			if (array[j-1] > array[j])
			{
				int temp = array[j];
				array[j] = array[j-1];
				array[j-1] = temp;
			}
		}
		low++;
	}
}
```

### 快速排序

#### 性质

#### 伪代码